# -*- coding: utf-8 -*-
"""Untitled47.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wZGAYzn2SZYNP8Uazy_TMvP0wD_GLkeV
"""
import numpy as np
import pandas as pd
from mod_poker_5 import *
from mod_fe import *
import torch as T

# (fold, check, call, hput, put, oput, all_in)
qfold =  [.994,.001,.001,.001,.001,.001,.001]
qcheck = [.001,.994,.001,.001,.001,.001,.001]
qcall =  [.001,.001,.994,.001,.001,.001,.001]
qhput =  [.001,.001,.001,.994,.001,.001,.001]
qput =   [.001,.001,.001,.001,.994,.001,.001]
qover =  [.001,.001,.001,.001,.001,.994,.001]
qall =   [.001,.001,.001,.001,.001,.001,.994]


afold =  [1,0,0,0,0,0,0]
acheck = [0,1,0,0,0,0,0]
acall =  [0,0,1,0,0,0,0]
ahput =  [0,0,0,1,0,0,0]
aput =   [0,0,0,0,1,0,0]
aover =  [0,0,0,0,0,1,0]
aall =   [0,0,0,0,0,0,1]

def prob_to_action(q):
    if q == qfold:
        return afold
    elif q==qcheck:
        return acheck
    elif q==qcall:
        return acall
    elif q==qhput:
        return ahput
    elif q==qput:
        return aput
    elif q==qover:
        return aover
    elif q==qall:
        return aall

class Agent_Allin_Any():
  def __init__(self):
    self.name = 'Allin_Any'
  def action(self, options, obs):
    if options[6] == 1:
      return aall
    elif options[5] == 1:
      return aover
    elif options[4] == 1:
      return aput
    elif options[3] == 1:
      return ahput
    elif options[2] == 1:
      return acall
    elif options[1] == 1:
      return acheck
    else:
      return afold

class Agent_CheckFold_Any():
  def __init__(self):
    self.name = 'CheckFold_Any'
  def action(self, options, obs):
    if options[1] == 1:
      return acheck
    elif options[0] == 1:
      return afold
    else:
      return aall


class Agent_Call_Any():
  def __init__(self):
    self.name = 'Call_Any'
  def action(self, options, obs):
    if options[1] == 1:
      return acheck
    elif options[2] == 1:
      return acall
    else:
      return aall

class Agent_Fold_Any():
  def __init__(self):
    self.name = 'Fold_Any'
  def action(self, options, obs):
    if options[0] == 1:
      return afold
    elif options[1] == 1:
      return acheck
    else:
      return aall

class Agent_Raise_Any():
  def __init__(self):
    self.name = 'Raise_Any'
  def action(self, options, obs):
    if options[3] == 1:
      return ahput
    elif options[4] == 1:
      return aput
    elif options[5] == 1:
      return aover
    elif options[6]==1:
      return aall
    elif options[2]==1:
      return acall

class Agent_Random():
  def __init__(self):
    self.name = 'Random'
    self.CheckFolder = Agent_CheckFold_Any()
  def action(self, options, obs):
    index= np.random.choice((np.nonzero(options))[0])
    action = [0,0,0,0,0,0,0]
    action[index]=1

    if action == afold:
      return self.CheckFolder.action(options, obs)
    else:
      return action

class Agent_Simple_Rational():
  def __init__(self,lims=[8,4]):
    self.name = 'Simple_Rational' + str(lims[0]) + str(lims[1])
    self.Raiser = Agent_Raise_Any()
    self.Caller = Agent_Call_Any()
    self.CheckFolder = Agent_CheckFold_Any()
    self.Alliner = Agent_Allin_Any()
    self.lims= lims

  def action(self, options, obs):

    if obs[0][0] == 9:
      return self.Alliner.action(options, obs)
    if obs[0][0] >= self.lims[0]:
      return self.Raiser.action(options, obs)
    elif obs[0][0] >= self.lims[1]:
      return self.Caller.action(options, obs)
    else:
      return self.CheckFolder.action(options, obs)

# best version lims = [8,3,0.4]
class Agent_Simple_Equity():
  def __init__(self,lims=[8,4,0.50]):
    self.name = 'Simple_Equity' + str(lims[0]) + str(lims[1]) + 'e' + str(lims[2])
    self.Raiser = Agent_Raise_Any()
    self.Caller = Agent_Call_Any()
    self.CheckFolder = Agent_CheckFold_Any()
    self.Alliner = Agent_Allin_Any()
    self.lims= lims

  def action(self, options, obs):
    if obs[0][0] == 9:
      return self.Alliner.action(options, obs)

    equity = np.abs((obs[0][5] - obs[0][4])/obs[0][8])

    if obs[0][0] >= self.lims[0] and equity < self.lims[2]:
      return self.Raiser.action(options, obs)
    elif obs[0][0] >= self.lims[1] and equity < self.lims[2]:
      return self.Caller.action(options, obs)
    else:
      return self.CheckFolder.action(options, obs)

# best version lims = [8,3,0.4]
class Agent_Standard_Equity():
  def __init__(self,lims=[8,3], equ=[0.5], probs=[]):
    self.name = 'S_E' + str(lims) + 'e' + str(equ)
    self.Raiser = Agent_Raise_Any()
    self.Caller = Agent_Call_Any()
    self.CheckFolder = Agent_CheckFold_Any()
    self.Alliner = Agent_Allin_Any()
    self.lims= lims
    self.equ= equ
    self.probs=probs

  def action(self, options, obs):
    if obs['cards'] == 9:
      return self.Alliner.action(options, obs)

    equity = np.abs((obs['put_contr'][1] - obs['put_contr'][0])/obs['put'])

    if obs['cards'] >= self.lims[0] and equity < self.equ[0]:
      return self.Raiser.action(options, obs)
    elif obs['cards'] >= self.lims[1] and equity < self.equ[0]:
      return self.Caller.action(options, obs)
    else:
      return self.CheckFolder.action(options, obs)

# best version lims = [8,3,0.4]
class Agent_General_Equity():
  def __init__(self, lims=[1, 8, 5],equ=[0.6, 0.5, 0.6],probs=[0.1]):
    self.name = 'S_E: lims=' + str(lims) + ', equ=' + str(equ) + ', probs=' + str(probs)
    self.Raiser = Agent_Raise_Any()
    self.Caller = Agent_Call_Any()
    self.CheckFolder = Agent_CheckFold_Any()
    self.Alliner = Agent_Allin_Any()
    self.lims= lims
    self.equ= equ
    self.probs=probs


  def action(self, options, obs):
    equity = np.abs((obs['put_contr'][1] - obs['put_contr'][0])/obs['put'])
    # bluffability = obs
    # equity2 = obs['put']/

    if obs['cards'] >= self.lims[0] and np.random.uniform() > self.probs[0] and equity < self.equ[0]:
      return self.Alliner.action(options, obs)
    if obs['cards'] >= self.lims[1] and equity < self.equ[1]:
      return self.Raiser.action(options, obs)
    elif obs['cards'] >= self.lims[2] and equity < self.equ[2]:
      return self.Caller.action(options, obs)
    else:
      return self.CheckFolder.action(options, obs)

class Human_Input():
  def __init__(self):
    self.name = 'Human_Input'
  def action(self, options, obs):
    print('your card = ', obs[0][0])
    print ('your options are: ', options)
    # options = (fold, check, call, raise, all_in)
    print ('select (0.fold, 1.check, 2.call, 3.hput, 4.put, 5.over, 6.all_in)')

    selected_array=np.array([0,0,0,0,0,0,0])
    selected = int(input())
    selected_array[selected] = 1

    if -1 in (options - selected_array):
      print('not legal, try again!')
      self.action(options,obs)


    elif selected ==6:
      print('all in!')
      return aall
    elif selected ==5:
      print('over!')
      return aover
    elif selected ==4:
      print('put!')
      return aput
    elif selected ==3:
      print('hput!')
      return ahput
    elif selected ==2:
      print('call!')
      return acall
    elif selected == 1:
      print('check!')
      return acheck
    elif selected == 0:
      print('fold!')
      return afold

# a = agent_a
# b = Human_Input()

def aganet_vs_human_play_game (a, b=Human_Input(), num_rounds=2):
  poker = Poker_4(INITIAL_STACK=20,debug=True,single_hand=False, num_rounds=num_rounds)
  log = ""
  while poker.game_ended == 0:


    row_added=0
    if poker.obs['agent_id'] == 0 and poker.hand_ended == 0:
      obs_get = poker.player_obs(poker.obs['agent_id']).copy()
      act_get =  a.action(poker.obs['player0_options'], feature_engineering(obs_get))
      print(a.q_eval_1.forward( T.tensor(feature_engineering(obs_get), dtype=T.float).to(a.q_eval_1.device)))
      obs, rews, last_action = poker.step(act_get)

    elif poker.obs['agent_id'] == 1 and poker.hand_ended == 0:
      obs_get = poker.player_obs(poker.obs['agent_id']).copy()
      act_get =  b.action(poker.obs['player1_options'], feature_engineering_p1(obs_get))
      obs, rews, last_action = poker.step(act_get)
    else:
      obs, rews, last_action = poker.step(None)

class Agent_Prob_Allin_Any():
  def __init__(self):
    self.name = 'Prob_Allin_Any'
  def probs(self, options, obs):
    if options[6] == 1:
      return qall
    elif options[5] == 1:
      return qover
    elif options[4] == 1:
      return qput
    elif options[3] == 1:
      return qhput
    elif options[2] == 1:
      return qcall
    elif options[1] == 1:
      return qcheck
    else:
      return qfold
  def action(self, options, obs):
    action = prob_to_action(self.probs(options, obs))
    return action

class Agent_Prob_CheckFold_Any():
  def __init__(self):
    self.name = 'Prob_CheckFold_Any'
  def probs(self, options, obs):
    if options[1] == 1:
      return qcheck
    elif options[0] == 1:
      return qfold
    else:
      return qall
  def action(self, options, obs):
    action = prob_to_action(self.probs(options, obs))
    return action

class Agent_Prob_Call_Any():
  def __init__(self):
    self.name = 'Prob_Call_Any'
  def probs(self, options, obs):
    if options[1] == 1:
      return qcheck
    elif options[2] == 1:
      return qcall
    else:
      return qall
  def action(self, options, obs):
    action = prob_to_action(self.probs(options, obs))
    return action


class Agent_Prob_Raise_Any():
  def __init__(self):
    self.name = 'Prob_Raise_Any'
  def probs(self, options, obs):
    if options[3] == 1:
      return qhput
    elif options[4] == 1:
      return qput
    elif options[5] == 1:
      return qover
    elif options[6]==1:
      return qall
    elif options[2]==1:
      return qcall
  def action(self, options, obs):
    action = prob_to_action(self.probs(options, obs))
    return action

class Agent_Prob_Equal():
  def __init__(self):
    self.name = 'Prob_Equal'
    self.CheckFolder = Agent_CheckFold_Any()

  def probs(self, options, obs):
    probs = np.array([0.0,0.0,0.0,0.0,0.0,0.0,0.0])
    num = np.nonzero(options)[0].shape[0]
    probs[np.nonzero(options)[0]] = 1/num
    return probs

  def action(self, options, obs):
    probs = self.probs(options, obs)
    index= np.random.choice(np.arange(7), p=probs)
    action = [0,0,0,0,0,0,0]
    action[index]=1
    if action == afold:
      return self.CheckFolder.action(options, obs)
    else:
      return action

class Agent_Prob_Rational():
  def __init__(self,lims=[8,4]):
    self.name = 'Prob_Rational' + str(lims[0]) + str(lims[1])
    self.Raiser = Agent_Prob_Raise_Any()
    self.Caller = Agent_Prob_Call_Any()
    self.CheckFolder = Agent_Prob_CheckFold_Any()
    self.Alliner = Agent_Prob_Allin_Any()
    self.lims= lims
  def probs(self, options, obs):
    if obs[0][0] == 9:
      return self.Alliner.probs(options, obs)
    if obs[0][0] >= self.lims[0]:
      return self.Raiser.probs(options, obs)
    elif obs[0][0] >= self.lims[1]:
      return self.Caller.probs(options, obs)
    else:
      return self.CheckFolder.probs(options, obs)
  def action(self, options, obs):
    action = prob_to_action(self.probs(options, obs))
    return action

class Agent_Prob_Equity():
  def __init__(self,lims=[8,4,0.50]):
    self.name = 'Prob_Equity' + str(lims[0]) + str(lims[1]) + 'e' + str(lims[2])
    self.Raiser = Agent_Prob_Raise_Any()
    self.Caller = Agent_Prob_Call_Any()
    self.CheckFolder = Agent_Prob_CheckFold_Any()
    self.Alliner = Agent_Prob_Allin_Any()
    self.lims= lims
  def probs(self, options, obs):
    if obs[0][0] == 9:
      return self.Alliner.probs(options, obs)
    equity = np.abs((obs[0][5] - obs[0][4])/obs[0][8])
    if obs[0][0] >= self.lims[0] and equity < self.lims[2]:
      return self.Raiser.probs(options, obs)
    elif obs[0][0] >= self.lims[1] and equity < self.lims[2]:
      return self.Caller.probs(options, obs)
    else:
      return self.CheckFolder.probs(options, obs)    
  def action(self, options, obs):
    action = prob_to_action(self.probs(options, obs))
    return action









# import copy
# class Agent_God():
#   def __init__(self):
#     self.name = 'Agent_God'
#     self.a = Agent_Prob_Equal()

#   def probs(self, poker,options, enemy = Agent_Prob_Equal()):
#     global Tree
#     global Tree_AV
#     global Tree_C
#     global Tree_obs
#     global Tree_opt
#     global Tree_S
#     Tree={}
#     Tree_AV={}
#     Tree_C={}
#     Tree_obs={}
#     Tree_opt={}
#     Tree_S ={}
#     obs_matrix, AV_matrix = MCT(poker, self.a, enemy)
#     AV_row = AV_matrix[0]
#     print(AV_row, 'AV_row')
#     best_args = np.array(AV_row).argsort()[-AV_row.shape[0]:][::-1]
#     probs = [0,0,0,0,0,0,0]
#     for i, a in enumerate(np.sort(AV_row)):
#       arg = best_args[i]
#       if options[arg] ==1:
#         probs[arg]=1
#         break

#     return probs

#   def action(self, poker, options, enemy = Agent_Prob_Equal()):
#     poker_dum = copy.deepcopy(poker)
#     poker_dum.debug = False
#     probs = self.probs(poker_dum, options, enemy = enemy)
#     action = probs
#     return action

# a = Agent_God()
# b = Agent_Prob_Call_Any()

# poker = Poker_4(INITIAL_STACK=20,debug=True,single_hand=True, num_rounds=1, random_start=True)
# step_func(poker, a, b)
# action = a.action(poker, poker.obs['player0_options'], enemy = b)
# _,_,_ = poker.step(action)
# b = Agent_Prob_Call_Any()